# 目录
<!-- vim-markdown-toc GFM -->

- [目录](#目录)
- [面向对象编程的基本结构](#面向对象编程的基本结构)
  - [常量与只读变量](#常量与只读变量)
  - [const和引用](#const和引用)
  - [const与指针](#const与指针)
- [运算符重载](#运算符重载)
- [继承和多态](#继承和多态)
- [模板](#模板)

> 写在前面
> 已经很久没有写代码了，包括自己高中的时候学的一些小伎俩基本也忘干净了，现在对于计算机课来说还是很紧张的。所以打算再写一篇文档，以复刻ai基础考前抱佛脚熟读讲义之便。
> 唉
>
> 哦哦，不过这个markdown转换成网页或者pdf应该会相对的好看一些，毕竟它不需要什么图片和数学公式，哪天我一定要学一学比较专业的前端，感觉自己对这个还挺有兴趣的

# 面向对象编程的基本结构
## 常量与只读变量
常量指的是在**编译**期间就可以确定的值，且整个运行期间常量的值不会发生变化。
在c++代码中，我们可以使用constexpr来表示常量，常量拥有可以在编译时就确定的特性，所以常量有着非常奇妙的应用：

>

## const和引用
只读和引用结合，可以产生四种不同的变量：
```c++
T x;
const T x;
T& x;
const T& x;
```
其中，T&、T、const T都可以用来初始化const T &类型的引用，但是const T类型的只读变量和const T&类型的引用不能用来初始化T&类型的引用（除非进行强制的类型转换），即：
```c++
int x = 1;
const int& y = x;//正确
int& z = x;//正确
int& w = y;//错误
```
即等式左边的读写能力一定要小于等于等式右边的读写能力。
这很好理解，因为如果等式左边的读写能力更强，就因为可以通过左边的引用修改右边一个较弱的引用，而这显然是有违正义的。

## const与指针

# 运算符重载

# 继承和多态

# 模板